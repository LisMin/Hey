/**
 * Created by hey on 2017/2/28.
 */
var HEY;
(function (HEY) {
    function test() {
        var vertices = new Float32Array([
            -0.5, -0.5, 0.0,
            0.5, -0.5, 0.0,
            0.0, 0.5, 0.0
        ]);
        var canvas = document.getElementById("render_canvas");
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        var renderer = new HEY.WebGL2Renderer({ canvas: canvas });
        var gl = renderer.gl;
        var buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
        var vertexShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertexShader, HEY.Shaders.v_default);
        gl.compileShader(vertexShader);
        var succ = gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS);
        if (!succ) {
            var log = gl.getShaderInfoLog(vertexShader);
            console.log("compile shader error:", log);
            return;
        }
        var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragmentShader, HEY.Shaders.f_default);
        gl.compileShader(fragmentShader);
        succ = gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS);
        if (!succ) {
            var log = gl.getShaderInfoLog(fragmentShader);
            console.log(log);
            return;
        }
        var program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        succ = gl.getProgramParameter(program, gl.LINK_STATUS);
        if (!succ) {
            var log = gl.getProgramInfoLog(program);
            console.log(log);
            return;
        }
        gl.deleteShader(vertexShader);
        gl.deleteShader(fragmentShader);
        gl.useProgram(program);
    }
    HEY.test = test;
})(HEY || (HEY = {}));
/**
 * Created by hey on 2017/2/28.
 */
var HEY;
(function (HEY) {
    var Shaders;
    (function (Shaders) {
        Shaders.v_default = "#version 300 es\n            layout (location = 0) in vec3 position;\n            void main()\n            {\n                 gl_Position = vec4(position.x, position.y, position.z, 1.0);\n            }\n        ";
        Shaders.f_default = "#version 300 es\n            precision highp float;\n            out vec4 color;\n            \n            void main()\n            {\n                color = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n            }\n    ";
    })(Shaders = HEY.Shaders || (HEY.Shaders = {}));
})(HEY || (HEY = {}));
/**
 * Created by hey on 2017/2/28.
 */
var HEY;
(function (HEY) {
    var WebGL2Renderer = (function () {
        function WebGL2Renderer(parameters) {
            if (parameters === void 0) { parameters = null; }
            this.gl = null;
            parameters = parameters || {};
            var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas'), _context = parameters.context !== undefined ? parameters.context : null, _alpha = parameters.alpha !== undefined ? parameters.alpha : false, _depth = parameters.depth !== undefined ? parameters.depth : true, _stencil = parameters.stencil !== undefined ? parameters.stencil : true, _antialias = parameters.antialias !== undefined ? parameters.antialias : false, _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true, _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false;
            // initialize
            var gl;
            try {
                var attributes = {
                    alpha: _alpha,
                    depth: _depth,
                    stencil: _stencil,
                    antialias: _antialias,
                    premultipliedAlpha: _premultipliedAlpha,
                    preserveDrawingBuffer: _preserveDrawingBuffer
                };
                gl = _context || _canvas.getContext('webgl2', attributes);
                if (gl === null) {
                    if (_canvas.getContext('webgl2') !== null) {
                        throw 'Error creating WebGL2 context with your selected attributes.';
                    }
                    else {
                        throw 'Error creating WebGL2 context.';
                    }
                }
                _canvas.addEventListener('webglcontextlost', function (event) {
                    event.preventDefault();
                }, false);
            }
            catch (error) {
                console.error('THREE.WebGL2Renderer: ' + error);
            }
            this.gl = gl;
        }
        return WebGL2Renderer;
    }());
    HEY.WebGL2Renderer = WebGL2Renderer;
})(HEY || (HEY = {}));
//# sourceMappingURL=bundle.min.js.map